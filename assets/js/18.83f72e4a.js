(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{414:function(t,v,_){t.exports=_.p+"assets/img/image-20230808154257476.39f48082.png"},415:function(t,v,_){t.exports=_.p+"assets/img/image-20230808154814466.6791cbb0.png"},416:function(t,v,_){t.exports=_.p+"assets/img/image-20230808155520771.0bb6c872.png"},417:function(t,v,_){t.exports=_.p+"assets/img/image-20230808155620334.f5e9938f.png"},418:function(t,v,_){t.exports=_.p+"assets/img/image-20230808155225911.6ef4c942.png"},419:function(t,v,_){t.exports=_.p+"assets/img/image-20230808155401814.f6b144cd.png"},420:function(t,v,_){t.exports=_.p+"assets/img/image-20230808155555449.c30159eb.png"},421:function(t,v,_){t.exports=_.p+"assets/img/image-20230808153741320.d311df02.png"},422:function(t,v,_){t.exports=_.p+"assets/img/image-20230808150136409.a6718690.png"},423:function(t,v,_){t.exports=_.p+"assets/img/image-20230910234212398.6088f720.png"},424:function(t,v,_){t.exports=_.p+"assets/img/image-20230910234259523.6ce478a7.png"},425:function(t,v,_){t.exports=_.p+"assets/img/6dea3b3682bba505488559737ec830c2.6dea3b36.png"},426:function(t,v,_){t.exports=_.p+"assets/img/image-20230808144018725.abe3616b.png"},427:function(t,v,_){t.exports=_.p+"assets/img/image-20230808144035838.c185f157.png"},503:function(t,v,_){"use strict";_.r(v);var s=_(14),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"模拟卷i"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模拟卷i"}},[t._v("#")]),t._v(" 模拟卷Ⅰ")]),t._v(" "),v("h3",{attrs:{id:"遗漏知识点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#遗漏知识点"}},[t._v("#")]),t._v(" 遗漏知识点")]),t._v(" "),v("p",[t._v("数据的最小单位是：数据项，数据的几种单位")]),t._v(" "),v("img",{attrs:{src:_(414)}}),t._v(" "),v("p",[t._v("数据结构包含三方面内容：逻辑结构、存储结构和数据的运算")]),t._v(" "),v("img",{attrs:{src:_(415)}}),t._v(" "),v("p",[t._v("选项中只有栈是逻辑结构，其余都是存储结构，故选 A")]),t._v(" "),v("p",[t._v("子串的定义是严格的相邻串，如"),v("code",[t._v("aabc")]),t._v("是"),v("code",[t._v("dacdaabcdd")]),t._v("的子串，而"),v("code",[t._v("daca")]),t._v("不是子串，c 和 a 被 d 隔开，子串定位运算又叫串的模式匹配")]),t._v(" "),v("p",[t._v("动态规划可用于解决哪些问题？0/1背包问题，硬币找零问题、整数划分问题和背包问题不可被动态规划解决，必须具备最优子结构和子问题重叠这两个特性")]),t._v(" "),v("p",[t._v("图的 DFS 等价于树的什么序遍历？先序")]),t._v(" "),v("p",[t._v("时间复杂度分析：O(n)，O(nlogn)，O(nlogn)")]),t._v(" "),v("img",{attrs:{src:_(416)}}),t._v(" "),v("img",{attrs:{src:_(417)}}),t._v(" "),v("p",[t._v("哈希散列删除结点，拉链法可直接删除，而线性探测法不行")]),t._v(" "),v("img",{attrs:{src:_(418)}}),t._v(" "),v("p",[t._v("函数值应当以等概率取其值域的每个值，而平均概率 ≠ 等概率")]),t._v(" "),v("img",{attrs:{src:_(419)}}),t._v(" "),v("p",[t._v("稀疏索引：分组建立")]),t._v(" "),v("img",{attrs:{src:_(420)}}),t._v(" "),v("h3",{attrs:{id:"树的结点、度、高度关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#树的结点、度、高度关系"}},[t._v("#")]),t._v(" 树的结点、度、高度关系")]),t._v(" "),v("p",[t._v("树的结点数永远比度数多一个：度数 + 1 = 结点数")]),t._v(" "),v("p",[t._v("树的空指针个数永远比结点数多一个：结点数 + 1 = 空指针数")]),t._v(" "),v("p",[t._v("对于二叉树而言有：度为 2 的结点数 + 1 = 度为 1 的结点数（叶子结点数）")]),t._v(" "),v("ul",[v("li",[t._v("注意，这里的度数和树的度不是一个概念，度是指最大分叉数，如三叉树的度为 3，m 叉树的度为 m")])]),t._v(" "),v("p",[t._v("对于完全二叉树")]),t._v(" "),v("ul",[v("li",[t._v("前 n 层的满二叉树结点总数为：2^n-1")]),t._v(" "),v("li",[t._v("第 k 层的结点数上限为：2^(k-1)")])]),t._v(" "),v("p",[t._v("不妨令 k = n+1，则有第 k 层的结点数上限为前 k-1 层所有结点数之和再加一")]),t._v(" "),v("h3",{attrs:{id:"矩阵的表示方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#矩阵的表示方法"}},[t._v("#")]),t._v(" 矩阵的表示方法")]),t._v(" "),v("p",[t._v("三种，三元组表示稀疏矩阵，十字链表法")]),t._v(" "),v("h3",{attrs:{id:"受限队列和栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#受限队列和栈"}},[t._v("#")]),t._v(" 受限队列和栈")]),t._v(" "),v("img",{attrs:{src:_(421)}}),t._v(" "),v("p",[t._v("我直接把所有可能列举出来一个一个考虑，找到符合（1）的序列 4132")]),t._v(" "),v("h3",{attrs:{id:"折半和快排"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#折半和快排"}},[t._v("#")]),t._v(" 折半和快排")]),t._v(" "),v("p",[t._v("折半查找时，可以通过构造一颗平衡二叉树帮助运算，计算其平均查找长度\n$$\n\\frac{\\sum高度\\times结点个数}{元素个数}\n$$\n快排的第一步一定是把首尾元素交换，左右指针向中间移动，最后把末尾元素和右指针元素交换回来，在写每轮顺序时一定要细心")]),t._v(" "),v("img",{attrs:{src:_(422)}}),t._v(" "),v("p",[t._v("排序过程代码，根据严的教材，采用一个独立的 pivot 变量存储当前枢纽，用空位的方式放置指针元素")]),t._v(" "),v("img",{attrs:{src:_(423)}}),t._v(" "),v("img",{attrs:{src:_(424)}}),t._v(" "),v("p",[t._v("每个分组中元素的顺序严格按照上面的代码进行，如第一趟")]),t._v(" "),v("ul",[v("li",[t._v("初始 left 指向 29，right 指向 10，则直接将 10 写入 29，right 指向的 10 变为空位")]),t._v(" "),v("li",[t._v("此时 left 右移，找到第一个大于 pivot 的元素，发现是 47，直接将 47 写入右边的 10 的位置（空位），原 47 处变为空位")]),t._v(" "),v("li",[t._v("再左移 right，找到第一个小于 pivot 的元素，12，写入原 47 处，而 12 处变为空位")]),t._v(" "),v("li",[t._v("再右移 left，找比 29 大的元素，途中 left 已经大于 right，故将 pivot 写入空位（原 12 的位置），得到一轮排序结果")])]),t._v(" "),v("img",{attrs:{src:_(425)}}),t._v(" "),v("h3",{attrs:{id:"散列表构造"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#散列表构造"}},[t._v("#")]),t._v(" 散列表构造")]),t._v(" "),v("p",[t._v("装填因子 α 为关键字数量除以表长（无论是拉链法还是线性探测法均如此），在求解表长时向上取整，散列函数若未给出，除留余数法的模数默认取不大于表长的最大素数（若表长为素数，则模数取表长）")]),t._v(" "),v("img",{attrs:{src:_(426)}}),t._v(" "),v("img",{attrs:{src:_(427)}}),t._v(" "),v("p",[t._v("1、已知关键字数量为 11，装填因子 α = 0.75，则表长 L 为\n$$\n\\lceil\\frac{11}{0.75}\\rceil=15\n$$\n故模数 P = 13（不大于 15 的最大素数），注意到题目要求用拉链法解决冲突，于是表长实际上"),v("strong",[t._v("塌陷")]),t._v("为 13")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("0")]),t._v(" "),v("th",[t._v("1")]),t._v(" "),v("th",[t._v("2")]),t._v(" "),v("th",[t._v("3")]),t._v(" "),v("th",[t._v("4")]),t._v(" "),v("th",[t._v("5")]),t._v(" "),v("th",[t._v("6")]),t._v(" "),v("th",[t._v("7")]),t._v(" "),v("th",[t._v("8")]),t._v(" "),v("th",[t._v("9")]),t._v(" "),v("th",[t._v("10")]),t._v(" "),v("th",[t._v("11")]),t._v(" "),v("th",[t._v("12")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("26")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("41")]),t._v(" "),v("td",[t._v("68")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("44")]),t._v(" "),v("td",[t._v("6")]),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("36")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("38")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("15")]),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("12")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("51")])]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("12")])])])]),t._v(" "),v("p",[t._v("2、查找成功平均长度将除以关键字个数，7 个在第一层，2 个在第二岑...\n$$\nASL_1=\\frac{7\\times1+2\\times2+3+4}{11}=\\frac{18}{11}\n$$\n3、查找失败平均长度将除以表长，为空则不查找，即查找次数记为 0\n$$\nASL_2=\\frac{5\\times1+2+4}{13}=\\frac{11}{13}\n$$")])])}),[],!1,null,null,null);v.default=a.exports}}]);