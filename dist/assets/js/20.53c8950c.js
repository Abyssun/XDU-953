(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{392:function(v,_,i){v.exports=i.p+"assets/img/image-20240201141734896.20fd1662.png"},393:function(v,_,i){v.exports=i.p+"assets/img/image-20240201141804452.c5b2f9ab.png"},394:function(v,_,i){v.exports=i.p+"assets/img/image-20240201141838527.84f9d077.png"},395:function(v,_,i){v.exports=i.p+"assets/img/image-20240201141857048.f732fa3e.png"},396:function(v,_,i){v.exports=i.p+"assets/img/image-20240201141913131.a3d2d19e.png"},397:function(v,_,i){v.exports=i.p+"assets/img/image-20240201141933415.6f88c33f.png"},398:function(v,_,i){v.exports=i.p+"assets/img/image-20240201142014228.99be709a.png"},399:function(v,_,i){v.exports=i.p+"assets/img/image-20240201142034660.0de78463.png"},400:function(v,_,i){v.exports=i.p+"assets/img/image-20240201142101075.a4b33ca1.png"},426:function(v,_,i){"use strict";i.r(_);var t=i(14),l=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"单选"}},[v._v("单选")]),v._v(" "),_("p",[v._v("1.数据的基本单位是 ()")]),v._v(" "),_("ul",[_("li",[v._v("A. 数据结构")]),v._v(" "),_("li",[v._v("B. 数据元素")]),v._v(" "),_("li",[v._v("C. 数据项")]),v._v(" "),_("li",[v._v("D. 文件")])]),v._v(" "),_("p",[v._v("2.在逻辑上可以把数据结构分成 ()")]),v._v(" "),_("ul",[_("li",[v._v("A. 动态结构和静态结构")]),v._v(" "),_("li",[v._v("B. 紧凑结构和非紧凑结构")]),v._v(" "),_("li",[v._v("C. 内部结构和外部结构")]),v._v(" "),_("li",[v._v("D. 线性结构和非线性结构")])]),v._v(" "),_("p",[v._v("3.不带头结点的单链表 head 为空的判定条件是 ()")]),v._v(" "),_("ul",[_("li",[v._v("A. head=NULL")]),v._v(" "),_("li",[v._v("B. head->next=NULL")]),v._v(" "),_("li",[v._v("C. head->next=head")]),v._v(" "),_("li",[v._v("D. head!=NULL")])]),v._v(" "),_("p",[v._v("4.在一个单链表中，若要在指 p 所指结点之后插入指针 s所指结点，则执行 ()")]),v._v(" "),_("ul",[_("li",[v._v("A. s->next=p;p->next=s;")]),v._v(" "),_("li",[v._v("B. s->next=p->next;p->next=s;")]),v._v(" "),_("li",[v._v("C. s->next=p->next; p=s;")]),v._v(" "),_("li",[v._v("D. p->next=s;s->next=p;")])]),v._v(" "),_("p",[v._v("5.串是一种特殊的线性表，其特殊性体现在 ()")]),v._v(" "),_("ul",[_("li",[v._v("A.可以顺序存储")]),v._v(" "),_("li",[v._v("C.可以连接存储")]),v._v(" "),_("li",[v._v("B.数据元素是一个字符")]),v._v(" "),_("li",[v._v("D.数据元素可以是多个字符")])]),v._v(" "),_("p",[v._v("6.二维数组 M 的成员是 6 个字符每个字符占一个存储单元组成的，行下标 i 的范用从 0 到 8，列下标 j 的范围从 0 到 9，则存放M至少需要 () 个存储单元")]),v._v(" "),_("ul",[_("li",[v._v("A. 90")]),v._v(" "),_("li",[v._v("B. 180")]),v._v(" "),_("li",[v._v("C. 240")]),v._v(" "),_("li",[v._v("D. 540")])]),v._v(" "),_("p",[v._v("7.当利用大小为n 的数顺序存储一个栈时，假定用 top-n 表示空，则向这个栈插入一个元素时，首先应执行 ()（top 为顶指针）")]),v._v(" "),_("ul",[_("li",[v._v("A. top++")]),v._v(" "),_("li",[v._v("B. top--")]),v._v(" "),_("li",[v._v("C. top=0")]),v._v(" "),_("li",[v._v("D. top")])]),v._v(" "),_("p",[v._v("8.设长度为 n 的链队列用单循环链表表示，若只设头指计，则入队和山队操作的时间复分 ()")]),v._v(" "),_("ul",[_("li",[v._v("A. O(1), O(1)")]),v._v(" "),_("li",[v._v("B. O(1), O(n)")]),v._v(" "),_("li",[v._v("C. O(n), O(1)")]),v._v(" "),_("li",[v._v("D. O(n), O(n)")])]),v._v(" "),_("p",[v._v("9.任何一棵二树的叶子结点在前序、中序和后序遍历序列中的相对次序 ()")]),v._v(" "),_("ul",[_("li",[v._v("A. 不发生改变")]),v._v(" "),_("li",[v._v("B. 发生改变")]),v._v(" "),_("li",[v._v("C. 不能确定")]),v._v(" "),_("li",[v._v("D. 以上都不对")])]),v._v(" "),_("p",[v._v("10.线索二叉链表是利用 () 域存储后继结点的地址")]),v._v(" "),_("ul",[_("li",[v._v("A. Ichild")]),v._v(" "),_("li",[v._v("B. data")]),v._v(" "),_("li",[v._v("C. rchild")]),v._v(" "),_("li",[v._v("D. root")])]),v._v(" "),_("p",[v._v("11.单链表中，增加头结点的目的是为了 ()")]),v._v(" "),_("ul",[_("li",[v._v("A. 使单链表至少有一个结点")]),v._v(" "),_("li",[v._v("B. 标示表结点中首结点的位置")]),v._v(" "),_("li",[v._v("C. 方便运算的实现")]),v._v(" "),_("li",[v._v("D. 说明单链表是线性表的链式存储实现")])]),v._v(" "),_("p",[v._v("12.无向图 G=(V,E)，其中 V={a,b,c,d,c,f}，E={(a,b),(a,e),(a, c),(b,e),(c,f),(f,d),(e,d)，对该图进行深度优先遍历，得到的顶点序列正确的是 ()")]),v._v(" "),_("ul",[_("li",[v._v("A. a,b,e,c,d,f")]),v._v(" "),_("li",[v._v("B. a,c,f,e,b,d")]),v._v(" "),_("li",[v._v("C. a,e,b,c,f,d")]),v._v(" "),_("li",[v._v("D. a,e,d,f,c,b")])]),v._v(" "),_("p",[v._v("13.设散列表长度为 m，k 为关键字用 p 去除 k，将所得的余数作为的散列地址，即\nH(k)=k%p。为了减少发生的冲突的频率，一般取 p 为()\nA. 小于等于m的最大偶数\nB. m\nC. 大于等于m的最小素数\nD. 小于等于m的最大素数")]),v._v(" "),_("p",[v._v("14.矩阵连乘问题可以用下列哪种方法解()")]),v._v(" "),_("ul",[_("li",[v._v("A. 贪心算法")]),v._v(" "),_("li",[v._v("B. 分治递归算法")]),v._v(" "),_("li",[v._v("C. 动态规划")]),v._v(" "),_("li",[v._v("D. Kruskal 算法")])]),v._v(" "),_("p",[v._v("15.关于动规划算法下列说法不正确的是()")]),v._v(" "),_("ul",[_("li",[v._v("A. 用于求解具有某种最优性质的问题")]),v._v(" "),_("li",[v._v("B. 以自顶向下的方式计算最优值")]),v._v(" "),_("li",[v._v("C. 适用于动态规划法求解的问题，经分解得到的子问题往往不是相互独立的")]),v._v(" "),_("li",[v._v("D. 先求解子问题，再从子问题的解得到原问题的解")])]),v._v(" "),_("h2",{attrs:{id:"判断"}},[v._v("判断")]),v._v(" "),_("p",[v._v("1.算法的时间复杂度取决于问题的规模和待处理数据的初态")]),v._v(" "),_("p",[v._v("2.顺序表无需为表示结点间的逻辑关系而增加额外的存储空间")]),v._v(" "),_("p",[v._v("3.对双向链表来说，结点 *P 的存储位置既存放在其前趋结点的后继指针域中，也存放在它的后继结点的前趋指针域中")]),v._v(" "),_("p",[v._v("4.二树的子树没有左右次序之分")]),v._v(" "),_("p",[v._v("5.树型结构中，任何结点可以有多个前驱结点和后继结点")]),v._v(" "),_("p",[v._v("6模式匹配的改进算法-KMP算法的最大特点是指示主串的指针不需要回溯")]),v._v(" "),_("p",[v._v("7.空格串是零个字符组成的串")]),v._v(" "),_("p",[v._v("8.栈底元素是不能删除的元素")]),v._v(" "),_("p",[v._v("9.栈是一种对进栈、出栈操作总次数做了限制的线性表")]),v._v(" "),_("p",[v._v("10.无向图的邻接矩阵是一个对角矩阵")]),v._v(" "),_("p",[v._v("11.有向图的遍历不可采用广度优先搜索方法")]),v._v(" "),_("p",[v._v("12.把散列地址不同的结点，争夺同一个后继列地址的现象称为“冲突”")]),v._v(" "),_("p",[v._v("13.当一个问题的所有子问题都至少需要求解一次时，动态规划算法好于备忘录算法")]),v._v(" "),_("p",[v._v("14.能够用分治法求解的问题往往具有子问题重叠性质")]),v._v(" "),_("p",[v._v("15.贪心算法所做的贪心选择是仅在当前状态下做出最好的选择")]),v._v(" "),_("h2",{attrs:{id:"填空"}},[v._v("填空")]),v._v(" "),_("img",{attrs:{src:i(392)}}),v._v(" "),_("img",{attrs:{src:i(393)}}),v._v(" "),_("h2",{attrs:{id:"问题求解"}},[v._v("问题求解")]),v._v(" "),_("img",{attrs:{src:i(394)}}),v._v(" "),_("img",{attrs:{src:i(395)}}),v._v(" "),_("img",{attrs:{src:i(396)}}),v._v(" "),_("img",{attrs:{src:i(397)}}),v._v(" "),_("h2",{attrs:{id:"算法设计"}},[v._v("算法设计")]),v._v(" "),_("img",{attrs:{src:i(398)}}),v._v(" "),_("img",{attrs:{src:i(399)}}),v._v(" "),_("img",{attrs:{src:i(400)}})])}),[],!1,null,null,null);_.default=l.exports}}]);